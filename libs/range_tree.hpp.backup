#include "rich.hpp"
#include <algorithm>
#include <array>
#include <cassert>
#include <cmath>
#include <format>
#include <functional>
#include <iostream>
#include <iterator>
#include <map>
#include <memory>
#include <numeric>
#include <optional>
#include <ranges>
#include <set>
#include <span>
#include <stdexcept>
#include <type_traits>
#include <vector>

template <typename T>
class tree_view {
public:
  using element_type = T;
  using reference = T &;
  using value_type = std::remove_cv_t<T>;
  using pointer = T *;
  using size_type = std::span<T>::size_type;
  using iterator = std::span<T>::iterator;
  using reverse_iterator = std::span<T>::reverse_iterator;
  tree_view(std::span<T> data) : data(data){};
  [[nodiscard]] constexpr reference value() const noexcept { return data[data.size() / 2]; }
  [[nodiscard]] constexpr tree_view<T> lower_child() noexcept { return data.subspan(0, data.size() / 2); }
  [[nodiscard]] constexpr tree_view<T> upper_child() noexcept { return data.subspan(data.size() / 2 + 1); }
  [[nodiscard]] constexpr size_type size() const noexcept { return data.size(); }
  [[nodiscard]] constexpr auto empty() const noexcept { return data.empty(); }
  [[nodiscard]] constexpr bool is_leaf() const noexcept { return data.size() == 1; }
  [[nodiscard]] constexpr bool has_lower_child() const noexcept { return data.size() >= 2; }
  [[nodiscard]] constexpr bool has_upper_child() const noexcept { return data.size() >= 3; }
  [[nodiscard]] constexpr iterator begin() const noexcept { return data.begin(); }
  [[nodiscard]] constexpr iterator end() const noexcept { return data.end(); };
  [[nodiscard]] constexpr iterator rbegin() const noexcept { return data.rbegin(); };
  [[nodiscard]] constexpr iterator rend() const noexcept { return data.rend(); };

private:
  std::span<T> data;
};

template <typename TPoint, typename TValue, size_t Dimension = std::tuple_size_v<TPoint>>
class range_tree {
public:
  using point_type = TPoint;
  using value_type = TValue;
  using size_type = size_t;
  using key_type = std::tuple_element_t<Dimension - 1, TPoint>;
  using node_type = std::pair<key_type, range_tree<TPoint, TValue, Dimension - 1>>;
  range_tree() = default;
  range_tree(std::span<std::pair<point_type, value_type>> data) : nodes(2 * data.size() - 1) {
    std::ranges::sort(data, {}, [](const auto &x) { return std::get<Dimension - 1>(x.first); });
    _build_tree(tree_view<node_type>(nodes), data);
  }
  void _build_tree(tree_view<node_type> tree, std::span<std::pair<point_type, value_type>> data) {
    rich::console.show(data);
    if (tree.empty()||data.empty())
      return;
    // assert(!data.empty());
    // auto mid = data.size()/2;
    // auto mid = data.size() % 2 ==0 ? data.size()/2: (data.size()+1)/2;
    auto mid = data.size()/2;
    auto key = std::get<Dimension - 1>(data[mid].first);
    rich::console.para(std::format("current size of tree {}, and its value {}.",tree.size(),key));
    if (!tree.is_leaf()) {
      _build_tree(tree.lower_child(), data.subspan(0,mid));
      _build_tree(tree.upper_child(), data.subspan(mid));
    }
    auto next_dim = range_tree<point_type, value_type, Dimension - 1>{data};
    tree.value() = std::make_pair(key, std::move(next_dim));
  }
  template <std::output_iterator<value_type> I>
  void query(const point_type &lower, const point_type &upper, I result) {
    auto tree = tree_view<node_type>{nodes};
    auto lower_key = std::get<Dimension - 1>(lower);
    auto upper_key = std::get<Dimension - 1>(upper);
    while (!tree.is_leaf()) {
      if (tree.value().first < lower_key) {
        tree = tree.upper_child();
      } else if (tree.value().first < upper_key) {
        auto lower_node = tree.lower_child();
        while (!lower_node.is_leaf()) {
          if (lower_key <= lower_node.value().first) {
            // std::cout << std::format("seach upper child of {}, {}\n", lower_node.value().first, lower_node.upper_child().value().first);
            lower_node.upper_child().value().second.query(lower, upper, result);
            lower_node = lower_node.lower_child();
          } else {
            lower_node = lower_node.upper_child();
          }
        }
        auto upper_node = tree.upper_child();
        while (!upper_node.is_leaf()) {
          if (upper_key <= upper_node.value().first) {
            upper_node = upper_node.lower_child();
          } else {
            std::cout << std::format("seach lower child of {}, {}\n", upper_node.value().first, upper_node.lower_child().value().first);
            upper_node.lower_child().value().second.query(lower, upper, result);
            upper_node = upper_node.upper_child();
          }
        }
        break;
      } else {
        tree = tree.lower_child();
      }
    }
  }
  std::vector<node_type> nodes;
};

template <typename TPoint, typename TValue>
class range_tree<TPoint, TValue, 1> {
public:
  using point_type = TPoint;
  using value_type = TValue;
  using size_type = size_t;
  using key_type = std::tuple_element_t<0, TPoint>;
  using node_type = std::pair<key_type, value_type>;
  range_tree() = default;
  range_tree(std::span<std::pair<point_type, value_type>> data) {
    // std::ranges::sort(data,{},[](const auto &x){std::get<0>(x.first);});
    std::sort(data.begin(), data.end(), [](const auto &x, const auto &y) { return std::get<0>(x.first) < std::get<0>(y.first); });
    keys.reserve(data.size());
    values.reserve(data.size());
    for (auto &&[point, val] : data) {
      keys.push_back(std::get<0>(point));
      values.push_back(val);
    }
  }
  template <std::output_iterator<value_type> I>
  void query(const point_type &lower, const point_type &upper, I result) {
    auto lower_it = std::ranges::lower_bound(keys, std::get<0>(lower), {});
    auto upper_it = std::ranges::upper_bound(keys, std::get<0>(upper), {});
    auto lower_index = std::distance(keys.begin(), lower_it);
    auto upper_index = std::distance(keys.begin(), upper_it);
    for (size_type i = lower_index; i != upper_index; i++) {
      *result++ = values[i];
    }
  }

// private:
  std::vector<key_type> keys;
  std::vector<value_type> values;
};
